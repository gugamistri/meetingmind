# Story 1.1: Project Foundation Setup

## Status
Approved

## Story
**As a** developer starting work on MeetingMind,
**I want** a properly configured Tauri + React project structure with all core dependencies and build tools set up,
**so that** I can begin implementing the application's core features with a solid foundation.

## Acceptance Criteria
1. [ ] Tauri 2.0 project structure is established with Rust backend and React frontend
2. [ ] All core dependencies are installed and configured (audio processing, database, UI components)
3. [ ] Development build system works (can run `npm run tauri dev` successfully)
4. [ ] Basic project structure follows the defined source tree organization
5. [ ] Essential configuration files are in place and properly configured
6. [ ] Code quality tools (ESLint, Prettier, Clippy) are configured and running
7. [ ] Basic testing framework is set up for both frontend and backend
8. [ ] Project can be built for production (basic bundle without features)

## Tasks / Subtasks
- [ ] Task 1: Initialize Tauri 2.0 Project Structure (AC: 1, 4)
  - [ ] Create root Cargo.toml workspace configuration
  - [ ] Set up src-tauri directory with basic main.rs and lib.rs
  - [ ] Initialize package.json with React 18 and TypeScript 5.0
  - [ ] Configure tauri.conf.json with basic app metadata and permissions
  - [ ] Create basic directory structure following source-tree.md specifications
  
- [ ] Task 2: Install and Configure Core Dependencies (AC: 2, 6)
  - [ ] Add Rust dependencies: tokio, sqlx, cpal, onnxruntime, reqwest, serde, thiserror, anyhow
  - [ ] Add frontend dependencies: React 18, TypeScript 5.0, Zustand, Radix UI, Tailwind CSS
  - [ ] Configure Vite 5.0 build tool with React plugin and TypeScript support
  - [ ] Set up ESLint and Prettier for frontend code quality
  - [ ] Configure Clippy for Rust code quality
  
- [ ] Task 3: Configure Build and Development System (AC: 3, 8)
  - [ ] Set up Vite configuration for frontend development
  - [ ] Configure Tauri development server integration
  - [ ] Test development build with `npm run tauri dev`
  - [ ] Verify production build process works
  - [ ] Set up package.json scripts for common development tasks
  
- [ ] Task 4: Establish Testing Framework Foundation (AC: 7)
  - [ ] Configure Vitest for frontend unit testing
  - [ ] Set up Cargo test configuration for Rust backend testing
  - [ ] Create basic test structure following testing strategy
  - [ ] Add example test files to verify testing setup works
  
- [ ] Task 5: Create Basic Application Shell (AC: 4, 8)
  - [ ] Implement basic Tauri main.rs with minimal command structure
  - [ ] Create basic React App.tsx with routing placeholder
  - [ ] Set up basic Tailwind CSS configuration with design system colors
  - [ ] Implement basic error boundaries and loading states
  - [ ] Create placeholder components for main application sections

## Dev Notes

### Technology Stack Information
**Source References**: [Source: architecture/tech-stack.md]

**Backend (Rust) Core Dependencies**:
- Tauri 2.0: Desktop application framework with security features and native system integration
- Tokio 1.0: Asynchronous runtime for concurrent operations
- SQLite + sqlx: Local database with async SQL query interface and FTS5 full-text search
- CPAL: Cross-platform audio capture library for system audio processing
- ONNX Runtime: ML inference engine for local Whisper models
- reqwest: HTTP client for external API integration with TLS 1.3 support
- serde + serde_json: Serialization framework for data interchange
- thiserror + anyhow: Structured error handling system

**Frontend Dependencies**:
- React 18: Concurrent features with automatic batching and improved Suspense
- TypeScript 5.0: Advanced type features with improved performance
- Vite 5.0: Fast development server with HMR and optimized Rollup builds
- Zustand: Lightweight state management (~2KB) with TypeScript support
- Radix UI: WAI-ARIA compliant accessible components (unstyled)
- Tailwind CSS: Utility-first styling with PurgeCSS optimization

### Project Structure Requirements
**Source References**: [Source: architecture/source-tree.md]

**Root Structure**:
```
meeting-mind/
├── src-tauri/          # Rust backend with domain-based modules
├── src/                # React frontend with feature-based organization
├── docs/               # Documentation (architecture, PRD)
├── tests/              # Integration and E2E tests
├── models/             # Local AI models (Whisper ONNX)
├── public/             # Static frontend assets
```

**Backend Module Organization**:
- `audio/` - Audio capture and processing domain
- `transcription/` - Speech-to-text conversion domain  
- `storage/` - Data persistence with SQLite
- `commands/` - Tauri command handlers for frontend communication
- `security/` - Encryption and privacy protection

**Frontend Structure**:
- `components/` - Feature-organized UI components (common, meeting, transcription, audio)
- `hooks/` - Custom React hooks by domain
- `stores/` - Zustand state management stores
- `types/` - TypeScript definitions
- `services/` - External service communication layer

### Configuration Requirements
**Source References**: [Source: architecture/tech-stack.md, architecture/coding-standards.md]

**Essential Configuration Files**:
- `Cargo.toml`: Rust workspace with all backend dependencies listed
- `package.json`: Frontend dependencies and development scripts
- `tauri.conf.json`: App metadata, bundle settings, and security permissions
- `tsconfig.json`: TypeScript strict mode with proper path mapping
- `tailwind.config.js`: Design system colors (green/teal palette) and responsive utilities
- `vite.config.ts`: React plugin, build optimization, and manual chunks configuration
- `vitest.config.ts`: Testing framework setup with Jest-compatible API

### Coding Standards to Apply
**Source References**: [Source: architecture/coding-standards.md]

**Rust Standards**:
- Use snake_case for modules, functions, variables
- PascalCase for structs and enums  
- Implement comprehensive error handling with custom error types
- Use async/await consistently for I/O operations
- Document public APIs with rustdoc comments
- Apply clippy linting rules

**TypeScript Standards**:
- PascalCase for components, interfaces
- camelCase for functions, variables
- kebab-case for file names
- Use strict type definitions with readonly where appropriate
- Implement branded types for IDs
- Use clsx for conditional CSS classes

### Security and Privacy Guidelines
**Source References**: [Source: architecture/tech-stack.md#security-stack]
- ChaCha20Poly1305 encryption for sensitive data at rest
- TLS 1.3 for all external API communications  
- Device-based authentication (no user accounts in MVP)
- Local-first data processing by default
- No sensitive data logging

### Testing Standards
**Source References**: [Source: architecture/9-development-guidelines.md#testing-strategy]

**Frontend Testing**:
- Use Vitest for unit testing with Jest-compatible API
- Testing Library React for component testing
- Test files should be co-located: `ComponentName.test.tsx`
- Focus on user behavior testing, not implementation details

**Backend Testing**:
- Cargo test for unit testing with `#[tokio::test]` for async tests
- Test modules in separate files: `tests.rs` 
- Integration tests in separate `tests/` directory
- Given-When-Then structure for test organization
- Mock external dependencies for reliable testing

**Test File Locations**:
- Frontend: `src/components/*/ComponentName.test.tsx`
- Backend: `src-tauri/src/*/tests.rs` and `tests/integration/`
- E2E Tests: `tests/e2e/`

### Performance Considerations
**Source References**: [Source: architecture/tech-stack.md, PRD.md#performance-requirements]
- Startup Time: <3 seconds cold start, <1 second warm start
- Memory Usage: <200MB baseline, <500MB during recording
- Build Size: Significantly smaller than Electron (~10MB vs ~100MB+)
- Use Vec::with_capacity() when size is known in Rust
- Implement React.memo() and useMemo() strategically for expensive operations

### Project Structure Notes
No conflicts found between epic requirements and architecture constraints. The source tree organization supports the foundation setup requirements and provides clear separation of concerns for future development.

## Testing

**Testing Framework Setup Requirements**:
- **Frontend**: Vitest + Testing Library React
  - Test files: `src/components/*/*.test.tsx`
  - Configuration: `vitest.config.ts` with Jest-compatible API
  - Coverage reporting enabled
  
- **Backend**: Cargo test framework
  - Test files: `src-tauri/src/*/tests.rs` for unit tests
  - Integration tests: `tests/integration/`
  - Async testing with `#[tokio::test]` attribute

**Testing Standards to Implement**:
- Given-When-Then test structure
- Mock external dependencies (audio devices, APIs)
- Test error handling paths
- Verify configuration loading works correctly
- Basic build and startup functionality tests

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-21 | 1.0 | Initial story creation | Claude (SM Agent) |

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent*

### Completion Notes List
*To be populated by development agent*

### File List
*To be populated by development agent*

## QA Results
*To be populated by QA agent*